---
applyTo: "**/*.{ts,tsx,js,jsx}"
---

# Web Application - Frontend

## Overview

This is the React 19-based frontend for Cricket247. It uses TanStack Router for routing, TanStack Query for data fetching, and shadcn/ui for components.

**Location**: `apps/web/`
**Port**: 3001 (development)
**Framework**: React 19 + TanStack Router + Vite

## Directory Structure

```
apps/web/src/
├── components/      # React components
│   └── ui/         # shadcn/ui components
├── routes/         # TanStack Router route files (file-based routing)
├── lib/            # Utilities and shared logic
├── utils/          # Helper functions
├── index.css       # Global styles (Tailwind)
└── main.tsx        # Application entry point
```

## Development Commands

```bash
# From repository root:
bun run dev:web          # Start development server
bun run build            # Build for production
bun run check-types      # TypeScript type checking
bun run check            # Lint and format

# From apps/web directory:
bun run dev              # Start Vite dev server
bun run deploy           # Build and deploy to Cloudflare Pages
```

## Key Patterns

### React Components

- Use functional components only (no class components)
- Use TypeScript for props
- Export as named exports (not default)
- Keep components focused and small
- Add keyboard handlers for interactive elements

```typescript
// apps/web/src/components/score-card.tsx
import type { Score } from "@/types/score";
import { Card } from "@/components/ui/card";

interface ScoreCardProps {
  score: Score;
  onUpdate?: (newScore: Score) => void;
}

export const ScoreCard = ({ score, onUpdate }: ScoreCardProps) => {
  const handleKeyDown = (event: React.KeyboardEvent) => {
    if (event.key === "Enter" || event.key === " ") {
      event.preventDefault();
      onUpdate?.(score);
    }
  };

  return (
    <Card
      role="button"
      tabIndex={0}
      onKeyDown={handleKeyDown}
      className="p-4 hover:shadow-md transition-shadow"
    >
      <h3 className="text-lg font-bold">{score.team}</h3>
      <p className="text-2xl">
        {score.runs}/{score.wickets}
      </p>
    </Card>
  );
};
```

### TanStack Router Routes

- Use file-based routing in `routes/` directory
- Implement loaders for data fetching
- Add error and pending states
- Route files auto-generate `routeTree.gen.ts`

```typescript
// apps/web/src/routes/scores/$matchId.tsx
import { createFileRoute } from "@tanstack/react-router";
import { useQuery } from "@tanstack/react-query";
import { apiClient } from "@/utils/orpc";
import { ScoreCard } from "@/components/score-card";
import { Loader } from "@/components/loader";

export const Route = createFileRoute("/scores/$matchId")({
  component: ScorePage,
  errorComponent: ({ error }) => (
    <div role="alert" className="p-4 text-red-600">
      <h2 className="text-xl font-bold">Error Loading Match</h2>
      <p>{error.message}</p>
    </div>
  ),
  pendingComponent: () => (
    <div className="flex items-center justify-center min-h-screen">
      <Loader />
    </div>
  ),
});

function ScorePage() {
  const { matchId } = Route.useParams();

  const { data, isLoading, error } = useQuery({
    queryKey: ["match", matchId],
    queryFn: async () => {
      const result = await apiClient.matches.get({ id: matchId });
      if (result.error) {
        throw new Error(result.error);
      }
      return result.data;
    },
  });

  if (isLoading) {
    return <Loader />;
  }

  if (error) {
    return <div role="alert">Error: {error.message}</div>;
  }

  return (
    <div className="container mx-auto p-4">
      <h1 className="text-3xl font-bold mb-4">{data.title}</h1>
      <ScoreCard score={data.score} />
    </div>
  );
}
```

### Data Fetching with TanStack Query

- Use for server state management
- Define query keys consistently
- Handle loading and error states
- Implement optimistic updates when appropriate

```typescript
// apps/web/src/hooks/use-matches.ts
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { apiClient } from "@/utils/orpc";

export const useMatches = () => {
  return useQuery({
    queryKey: ["matches"],
    queryFn: async () => {
      const result = await apiClient.matches.list();
      if (result.error) {
        throw new Error(result.error);
      }
      return result.data;
    },
    staleTime: 30_000, // 30 seconds
  });
};

export const useCreateMatch = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (data: CreateMatchInput) => {
      const result = await apiClient.matches.create(data);
      if (result.error) {
        throw new Error(result.error);
      }
      return result.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["matches"] });
    },
  });
};
```

### Styling with Tailwind

- Use utility classes for styling
- Follow responsive design patterns
- Ensure color contrast for accessibility
- Use shadcn/ui components when available

```typescript
// Good: Responsive, accessible, semantic
<button
  type="button"
  className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50"
  onClick={handleClick}
  onKeyDown={handleKeyDown}
  disabled={isLoading}
>
  {isLoading ? 'Loading...' : 'Submit'}
</button>

// Bad: Missing accessibility, no semantic HTML
<div
  className="px-4 py-2 bg-blue-600 text-white"
  onClick={handleClick}
>
  Submit
</div>
```

## Common Tasks

### Adding a New Page/Route

1. Create route file in `routes/` following naming conventions
2. Implement component with proper types
3. Add data fetching with TanStack Query if needed
4. Add error and loading states
5. Route will auto-generate in `routeTree.gen.ts`

### Adding a New Component

1. Create component file in `components/` (kebab-case)
2. Define TypeScript interface for props
3. Implement with accessibility in mind
4. Add keyboard handlers for interactions
5. Use Tailwind for styling
6. Export as named export

### Adding a shadcn/ui Component

1. Run: `bunx shadcn-ui@latest add <component-name>`
2. Component appears in `components/ui/`
3. Customize if needed
4. Import and use in your components

### Adding Global State

- Prefer server state with TanStack Query
- Use React Context for UI state if needed
- Consider Zustand for complex client state
- Keep state close to where it's used

## Important Rules

### Accessibility (Critical)

- Always include keyboard handlers (`onKeyDown`) with `onClick`
- Use semantic HTML elements (`<button>`, `<nav>`, `<main>`, etc.)
- Add ARIA attributes only when semantic HTML isn't enough
- Provide meaningful alt text for images
- Ensure proper heading hierarchy (`<h1>`, `<h2>`, etc.)
- Test with keyboard navigation
- Maintain color contrast ratios (WCAG AA minimum)

```typescript
// ✅ Good: Accessible interactive element
<button
  type="button"
  onClick={handleClick}
  onKeyDown={handleKeyDown}
  aria-label="Close dialog"
>
  <XIcon aria-hidden="true" />
</button>

// ❌ Bad: Not accessible
<div onClick={handleClick}>
  <XIcon />
</div>
```

### React Best Practices

- Keep hooks at the top level of components
- Don't call hooks conditionally
- Include all dependencies in useEffect/useCallback dependency arrays
- Use React.memo sparingly (only for expensive renders)
- Prefer controlled components for forms
- Handle errors with error boundaries
- Don't use useEffect unless necessary, refer to this link: https://react.dev/learn/you-might-not-need-an-effect

### TypeScript

- No `any` types
- No non-null assertions (`!`)
- Use `type` for props, `interface` for extendable contracts
- Use `import type` for type-only imports
- Prefer union types over enums

### Performance

- Use React 19 compiler (automatic optimizations)
- Lazy load routes with TanStack Router
- Optimize images (use proper formats and sizes)
- Minimize bundle size (check with `bun run build`)
- Use proper loading states to prevent layout shifts

### Error Handling

- Always handle error states in queries
- Provide user-friendly error messages
- Use error boundaries for component errors
- Log errors for debugging (but not in production)

```typescript
// ✅ Good: Comprehensive error handling
const { data, error, isLoading } = useQuery({
  queryKey: ["match", id],
  queryFn: fetchMatch,
});

if (error) {
  return (
    <div role="alert" className="p-4 bg-red-50 text-red-800 rounded">
      <p className="font-semibold">Failed to load match</p>
      <p className="text-sm">{error.message}</p>
    </div>
  );
}

// ❌ Bad: Silently swallows errors
const { data } = useQuery({
  queryKey: ["match", id],
  queryFn: fetchMatch,
});
```

## Deployment (Cloudflare Pages)

- Build outputs to `dist/`
- Configure build command: `bun run build`
- Set environment variables in Cloudflare dashboard
- Routes handled by client-side router
- API calls go to separate server deployment
