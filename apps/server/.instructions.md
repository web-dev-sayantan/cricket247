---
applyTo: "**/*.{ts,js}"
---

# Server Application - Backend API

## Overview
This is the Hono-based backend API for Cricket247. It handles authentication, database operations, and provides type-safe APIs via oRPC.

**Location**: `apps/server/`
**Port**: 3000 (development)
**Framework**: Hono + oRPC + Better-Auth

## Directory Structure
```
apps/server/src/
├── config/        # Configuration files and environment setup
├── db/            # Database schema, relations, and migrations
│   ├── schema/    # Drizzle table definitions
│   └── relations/ # Table relationships
├── lib/           # Shared utilities and helpers
│   └── auth.ts    # Authentication helpers (Better-Auth)
├── middleware/    # Hono middleware functions
├── routers/       # API route handlers (business logic)
├── routes/        # Route definitions and mounting
├── schemas/       # Zod validation schemas
├── services/      # Business logic and data access layer
└── utils/         # Utility functions
```

## Development Commands
```bash
# From repository root:
bun run dev:server        # Start development server with hot reload
bun run build             # Build for production
bun run check-types       # TypeScript type checking

# Database operations:
bun run db:push           # Push schema changes to database
bun run db:generate       # Generate migration files
bun run db:migrate        # Run pending migrations
bun run db:studio         # Open Drizzle Studio UI

# From apps/server directory:
bun run dev               # Start server
bun db:local              # Start local SQLite database
```

## Key Patterns

### Route Handlers
- Keep handlers small and focused
- Use middleware for cross-cutting concerns
- Validate all input with Zod schemas
- Return typed responses
- Handle errors explicitly

```typescript
// apps/server/src/routers/matches.ts
import { z } from 'zod';
import type { Context } from 'hono';
import { db } from '@/db';
import { matches } from '@/db/schema';

const createMatchSchema = z.object({
  title: z.string().min(1),
  team1: z.string(),
  team2: z.string(),
  startTime: z.string().datetime(),
});

export const createMatch = async (c: Context) => {
  try {
    const body = createMatchSchema.parse(await c.req.json());
    
    const newMatch = await db.insert(matches).values({
      id: crypto.randomUUID(),
      ...body,
      status: 'scheduled',
      createdAt: new Date(),
      updatedAt: new Date(),
    }).returning();

    return c.json({ data: newMatch[0] }, 201);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return c.json({ error: 'Validation failed', details: error.errors }, 400);
    }
    console.error('Failed to create match:', error);
    return c.json({ error: 'Internal server error' }, 500);
  }
};
```

### Database Queries
- Use Drizzle ORM typed queries
- Put complex queries in services layer
- Avoid raw SQL
- Use transactions for multi-step operations

```typescript
// apps/server/src/services/match-service.ts
import { db } from '@/db';
import { matches, teams } from '@/db/schema';
import { eq, and } from 'drizzle-orm';

export const getMatchWithTeams = async (matchId: string) => {
  const result = await db
    .select({
      match: matches,
      team1: teams,
      team2: teams,
    })
    .from(matches)
    .leftJoin(teams, eq(matches.team1Id, teams.id))
    .leftJoin(teams, eq(matches.team2Id, teams.id))
    .where(eq(matches.id, matchId))
    .limit(1);

  return result[0];
};
```

### Authentication
- Use Better-Auth helpers from `lib/auth.ts`
- Check authentication in middleware
- Verify permissions before data access
- Never hardcode secrets

```typescript
// apps/server/src/middleware/auth.ts
import { authMiddleware } from '@/lib/auth';

export const requireAuth = authMiddleware({
  onUnauthenticated: (c) => {
    return c.json({ error: 'Authentication required' }, 401);
  },
});
```

### Schema Definitions
- Define schemas in `db/schema/`
- Use TypeScript-first approach
- Add indexes for query performance
- Keep migrations in version control

```typescript
// apps/server/src/db/schema/users.ts
import { sqliteTable, text, integer, index } from 'drizzle-orm/sqlite-core';

export const users = sqliteTable('users', {
  id: text('id').primaryKey(),
  email: text('email').notNull().unique(),
  name: text('name'),
  role: text('role', { enum: ['admin', 'user'] }).notNull().default(''user'),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull(),
}, (table) => ({
  emailIdx: index('email_idx').on(table.email),
}));
```

## Common Tasks

### Adding a New API Endpoint
1. Create Zod schema in `schemas/`
2. Implement handler in `routers/`
3. Add route in `routes/`
4. Test with Postman or similar tool

### Adding a Database Table
1. Create schema file in `db/schema/`
2. Add relations in `db/relations/` if needed
3. Run `bun run db:generate` to create migration
4. Review generated migration
5. Run `bun run db:migrate` to apply

### Adding Authentication
1. Use existing Better-Auth setup in `lib/auth.ts`
2. Add middleware to protected routes
3. Check user roles/permissions as needed
4. Use environment variables for secrets

## Important Rules

### Security
- Never log sensitive data
- Validate all user input with Zod
- Use parameterized queries (Drizzle does this)
- Set proper CORS headers
- Use environment variables for secrets
- Sanitize error messages sent to clients

### Performance
- Add database indexes for frequently queried fields
- Use `.limit()` on queries
- Implement pagination for list endpoints
- Cache expensive operations when appropriate
- Use connection pooling (Drizzle handles this)

### Error Handling
- Always wrap route handlers in try-catch
- Return appropriate HTTP status codes
- Log errors for debugging (use structured logging)
- Don't expose internal error details to clients
- Validate input before database operations

## Cloudflare Workers Constraints
When deploying to Cloudflare Workers:
- No Node.js-specific APIs (fs, path, etc.)
- Keep bundle size small (<1MB recommended)
- Use environment bindings for secrets
- Stateless request handling
- Use Durable Objects for stateful logic if needed
